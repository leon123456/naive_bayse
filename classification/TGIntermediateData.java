package com.kuaishou.old.antispam.classification;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;

import com.kuaishou.old.split.ChineseSpliterSmart;
import com.kuaishou.old.util.StringEscapeUtil;

// CHECKSTYLE:OFF
public class TGIntermediateData implements Serializable {

    /**
     * auto generated by eclipse.
     */
    private static final long serialVersionUID = -420389048890617397L;

    /** �����. */
    public String[] classifications;
    /*x在c类里第一个词出现的概率*/
    public HashMap[] headOfXC;

    /** ����X�����C�³��ֵ�����. */
    public HashMap[] filesOfXC;
    /*N-Gram词典*/
    public HashMap[] filesOfXXC;
    /** ���������µ��ļ���Ŀ. */
    public int[] filesOfC;
    /** ��Ŀ¼�µ��ļ�����. */
    public int files;

    /** ����X�����C�³��ֵ����� */
    public HashMap[] tokensOfXC;
    /* N-Gram词典*/
    public HashMap[] tokensOfXXC;
    /** ���C�����е��ʵ�����. */
    public int[] tokensOfC;
    /** �������Ͽ��е��ʵ�����. */
    public int tokens;
    /*词组总数*/
    public int ngtokens;
    /** ����ѵ�����������ֵĵ���. */
    public HashSet<String> vocabulary;

    public HashSet<String> headVocabulary;

    public HashSet<TermsPair> termsVocabulary;

    /** �ı��������ϵĸ�Ŀ¼. */
    private transient String dir;
    /** ���Ͽ��е��ı��ļ����ַ�����. */
    private transient String encoding;

    public TGIntermediateData() {
        vocabulary = new HashSet<>();
        headVocabulary = new HashSet<>();
        termsVocabulary = new HashSet<>();
    }

    /**
     * Ԥ���㣬�����м�������ŵ�������.
     *
     * @param trainTextDir
     *            �Ѿ���������Ͽ⣬�ṹΪ
     * trainnedTextDir
     *            ��- ���1\
     *                    ��- �ļ�1.txt
     *                    ��- �ļ�2.txt ...
     *            ��- ���2\
     *                    ��- �ļ�1.txt
     *                    ��- �ļ�2.txt ...
     * @param txtEncoding
     *            ���Ͽ��е��ı��ļ�����
     * @throws FileNotFoundException
     */
    public final void generate(final String trainTextDir, final String txtEncoding,
            final String modelFile) throws FileNotFoundException {
        // һЩ��ʼ������
        dir = trainTextDir;
        if (txtEncoding == null) {
            encoding = "GBK"; // Ĭ���ı��ļ��ı���ΪGBK;
        } else {
            encoding = txtEncoding;
        }

        // ö��Ŀ¼����ø�������
        File tmpDir = new File(dir);
        System.out.println(dir);
        System.out.println(tmpDir.exists());
        if (!tmpDir.isDirectory()) {
            throw new IllegalArgumentException("ѵ�����Ͽ�����ʧ�ܣ� [" + dir + "]");
        }
        classifications = tmpDir.list();

        filesOfC = new int[classifications.length];
        filesOfXC = new HashMap[classifications.length];
        filesOfXXC = new HashMap[classifications.length];
        tokensOfC = new int[classifications.length];
        tokensOfXC = new HashMap[classifications.length];
        tokensOfXXC = new HashMap[classifications.length];
        headOfXC = new HashMap[classifications.length];
        for (int i = 0; i < classifications.length; i++) {
            tokensOfXC[i] = new HashMap<String, Integer>();
            tokensOfXXC[i] = new HashMap<TermsPair, Integer>();
            filesOfXC[i] = new HashMap<String, Integer>();
            filesOfXXC[i] = new HashMap<TermsPair, Integer>();
            headOfXC[i] = new HashMap<String, Integer>();
        }

        // ������������ļ�����������
        for (int i = 0; i < classifications.length; i++) {
            int n = calcFileCountOfClassification(i);
            filesOfC[i] = n;
            files += n; // �����ļ�����������
        }

        // ��õ��ʱ�
        try {
            long startTime = System.currentTimeMillis();
            extractVocabulary();
            long endTime = System.currentTimeMillis();
            System.out.println("extractVocabulary:" + (endTime - startTime) / 1000);
        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // ���������µ�����������������
        try {
            long startTime = System.currentTimeMillis();
            calculate();
            long endTime = System.currentTimeMillis();
            System.out.println("calculate:" + (endTime - startTime) / 1000);
        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // ��Ԥ����������д�뵽����
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(modelFile));
            out.writeObject(this);
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println();
    }

    public final void generate(final String trainTextDir, final String txtEncoding,
            final String modelFile, String flag) throws FileNotFoundException {
        // һЩ��ʼ������
        dir = trainTextDir;
        if (txtEncoding == null) {
            encoding = "GBK"; // Ĭ���ı��ļ��ı���ΪGBK;
        } else {
            encoding = txtEncoding;
        }

        // ö��Ŀ¼����ø�������
        File tmpDir = new File(dir);
        System.out.println(dir);
        System.out.println(tmpDir.exists());
        if (!tmpDir.isDirectory()) {
            throw new IllegalArgumentException("ѵ�����Ͽ�����ʧ�ܣ� [" + dir + "]");
        }
        classifications = tmpDir.list();

        filesOfC = new int[classifications.length];
        filesOfXC = new HashMap[classifications.length];
        filesOfXXC = new HashMap[classifications.length];
        tokensOfC = new int[classifications.length];
        tokensOfXC = new HashMap[classifications.length];
        tokensOfXXC = new HashMap[classifications.length];
        headOfXC = new HashMap[classifications.length];
        for (int i = 0; i < classifications.length; i++) {
            tokensOfXC[i] = new HashMap<String, Integer>();
            tokensOfXXC[i] = new HashMap<TermsPair, Integer>();
            filesOfXC[i] = new HashMap<String, Integer>();
            filesOfXXC[i] = new HashMap<TermsPair, Integer>();
            headOfXC[i] = new HashMap<String, Integer>();
        }

        // ������������ļ�����������
        for (int i = 0; i < classifications.length; i++) {
            int n = calcFileCountOfClassification(i);
            filesOfC[i] = n;
            files += n; // �����ļ�����������
        }

        // ��õ��ʱ�
        try {
            long startTime = System.currentTimeMillis();
            extractVocabulary(flag);
            long endTime = System.currentTimeMillis();
            System.out.println("extractVocabulary:" + (endTime - startTime) / 1000);
        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // ���������µ�����������������
        try {
            long startTime = System.currentTimeMillis();
            calculate(flag);
            long endTime = System.currentTimeMillis();
            System.out.println("calculate:" + (endTime - startTime) / 1000);
        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // ��Ԥ����������д�뵽����
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(modelFile));
            out.writeObject(this);
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println();
    }

    /** ��õ��ʱ�.
     * @throws IOException ��ȡ���Ͽ����
     */
    private void extractVocabulary() throws IOException {
        for (String c : classifications) {
            String[] filesPath = getFilesPath(dir, c);

            for (String file : filesPath) {
                //String text = getText(file, encoding);
                List<String> texts = getTextList(file, encoding);
                for (String text : texts) {
                    String[] terms;
                    // ���ķִʴ���(�ִʺ������ܻ�������ͣ�ôʣ�
                    text = StringEscapeUtil.filterByRegEx(text);
                    terms = ChineseSpliterSmart.split(text, " ").split(" ");
                    terms = ChineseSpliterSmart.dropStopWords(terms); // ȥ��ͣ�ôʣ�����Ӱ�����
                    if (terms.length != 0) {
                        headVocabulary.add(terms[0]);
                    }

                    for (String term : terms) { //ȥ���ظ�����
                        vocabulary.add(term);
                    }

                    for (int i = 0; i < terms.length - 1; i++) {
                        TermsPair tp = new TermsPair();
                        tp.terms1 = terms[i];
                        tp.terms2 = terms[i + 1];
                        termsVocabulary.add(tp);
                    }
                }
            }
        }
    }

    /** 提取词表的时候可以控制过滤字符串的函数
     * @throws IOException ��ȡ���Ͽ����
     */
    private void extractVocabulary(String flag) throws IOException {
        for (String c : classifications) {
            String[] filesPath = getFilesPath(dir, c);

            for (String file : filesPath) {
                //String text = getText(file, encoding);
                List<String> texts = getTextList(file, encoding);
                for (String text : texts) {
                    String[] terms;

                    terms = StringEscapeUtil.getTermsbyFilter(text, flag);

                    if (terms.length != 0) {
                        headVocabulary.add(terms[0]);
                    }

                    for (String term : terms) { //ȥ���ظ�����
                        vocabulary.add(term);
                    }

                    for (int i = 0; i < terms.length - 1; i++) {
                        TermsPair tp = new TermsPair();
                        tp.terms1 = terms[i];
                        tp.terms2 = terms[i + 1];
                        termsVocabulary.add(tp);
                    }
                }
            }
        }
    }

    /**
     * ����ѵ���ı������ڸ��������µ�ѵ���ı���Ŀ.
     *
     * @param c
     *            �����ķ���
     * @return ѵ���ı������ڸ��������µ�ѵ���ı���Ŀ
     * @throws FileNotFoundException
     */
    private int calcFileCountOfClassification(final int c) throws FileNotFoundException {
        int lines = 0;

        File classDir = new File(dir + File.separator + classifications[c]);
        for (File file : classDir.listFiles()) {
            System.out.println(file.getAbsolutePath());
            BufferedReader bufferedReader = new BufferedReader(
                    new InputStreamReader(new FileInputStream(file)));

            try {
                while (bufferedReader.readLine() != null) {
                    lines++;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            //lines +=  bufferedReader.lines().count();
        }

        return lines;
    }

    /**
     * ���� fileCountOfXC, fileCountOfC, fileCount, tokensOfXC, tokensOfC, tokens.
     *
     * @throws IOException
     */
    private void calculate() throws IOException {
        for (int i = 0; i < classifications.length; i++) {
            long startTime = System.currentTimeMillis();

            HashMap<String, Integer> tmpT = tokensOfXC[i];
            HashMap<String, Integer> tmpF = filesOfXC[i];
            HashMap<TermsPair, Integer> tmpTXX = tokensOfXXC[i];
            HashMap<TermsPair, Integer> tmpFXX = filesOfXXC[i];
            HashMap<String, Integer> tmpHead = headOfXC[i];

            String[] filesPath = getFilesPath(dir, classifications[i]);

            //filesOfC[i] = filesPath.length;
            //files += filesOfC[i];
            HashSet<String> words = new HashSet<>();
            HashSet<TermsPair> termsPairs = new HashSet<>();

            for (String file : filesPath) {

                List<String> textList = getTextList(file, encoding);
                System.out.println("textList.size " + textList.size());
                for (String text : textList) {
                    words.clear();
                    termsPairs.clear();
                    String[] terms;

                    // ���ķִʴ���(�ִʺ������ܻ�������ͣ�ôʣ�
                    text = StringEscapeUtil.filterByRegEx(text);
                    terms = ChineseSpliterSmart.split(text, " ").split(" ");
                    terms = ChineseSpliterSmart.dropStopWords(terms); // ȥ��ͣ�ôʣ�����Ӱ�����
                    Integer hvalue;
                    if (terms.length != 0) {
                        hvalue = tmpHead.get(terms[0]);
                        if (hvalue == null) {
                            tmpHead.put(terms[0], new Integer(1));
                        } else {
                            tmpHead.put(terms[0], hvalue + 1);
                        }
                    }

                    for (int ii = 0; ii < terms.length; ii++) {

                        Integer value1 = tmpT.get(terms[ii]);
                        if (value1 == null) {
                            tmpT.put(terms[ii], new Integer(1));
                        } else {
                            tmpT.put(terms[ii], value1 + 1);
                        }

                        if (ii < terms.length - 1) {
                            TermsPair tp = new TermsPair();
                            tp.terms1 = terms[ii];
                            tp.terms2 = terms[ii + 1];

                            //                    		if("玩".equals(tp.terms1)&&"快手".equals(tp.terms2)){
                            //                    			System.out.println(tp);
                            //                    		}
                            termsPairs.add(tp);
                            Integer value2 = tmpTXX.get(tp);
                            if (value2 == null) {
                                tmpTXX.put(tp, new Integer(1));
                            } else {
                                tmpTXX.put(tp, value2 + 1);
                            }

                            //                    		if("玩".equals(tp.terms1)&&"快手".equals(tp.terms2)){
                            //                    			System.out.println(tp + " :: " + tmpTXX.get(tp));
                            //                    		}

                        }
                    }

                    //                    for (String term : terms) { // ���㱾�����ÿ�����ʵĳ��ִ���
                    //                    	Integer value = tmpT.get(term);
                    //                        if(value == null) {
                    //                        	tmpT.put(term, new Integer(1));
                    //                        } else {
                    //                        	tmpT.put(term, value + 1);
                    //                        }
                    //                    }

                    // ��ʼ���� filesOfXC[i]
                    for (String term : terms) { //ȥ���ظ�����
                        words.add(term);
                    }
                    for (String key : words) {
                        Integer value = tmpF.get(key);
                        if (value == null) {
                            tmpF.put(key, new Integer(1));
                        } else {
                            value++;
                            tmpF.put(key, value);
                        }
                    }

                    for (TermsPair tp : termsPairs) {
                        Integer value = tmpFXX.get(tp);
                        if (value == null) {
                            tmpFXX.put(tp, new Integer(1));
                        } else {
                            tmpFXX.put(tp, value + 1);
                        }
                    }
                }
            }

            // ����������е��ʵĳ������� nC
            for (Entry<String, Integer> entry : tmpT.entrySet()) {
                tokensOfC[i] += entry.getValue();
            }

            tokens += tokensOfC[i]; // ���е��ʳ�������
            System.out.println("tokens :: " + classifications[i] + tokens);
            for (Entry<TermsPair, Integer> entry : tmpTXX.entrySet()) {
                ngtokens += entry.getValue();
            }
            System.out.println("ngtokens :: " + classifications[i] + ngtokens);

            long endTime = System.currentTimeMillis();
            System.out.println("class:" + classifications[i] + "类统计时间 :: "
                    + (endTime - startTime) / 1000 / 60 + "mins");
        }

    }

    /**
     * when calculate可以控制处理字符串的过滤函数
     *
     * @throws IOException
     */
    private void calculate(String flag) throws IOException {
        for (int i = 0; i < classifications.length; i++) {
            long startTime = System.currentTimeMillis();

            HashMap<String, Integer> tmpT = tokensOfXC[i];
            HashMap<String, Integer> tmpF = filesOfXC[i];
            HashMap<TermsPair, Integer> tmpTXX = tokensOfXXC[i];
            HashMap<TermsPair, Integer> tmpFXX = filesOfXXC[i];
            HashMap<String, Integer> tmpHead = headOfXC[i];

            String[] filesPath = getFilesPath(dir, classifications[i]);

            //filesOfC[i] = filesPath.length;
            //files += filesOfC[i];
            HashSet<String> words = new HashSet<>();
            HashSet<TermsPair> termsPairs = new HashSet<>();

            for (String file : filesPath) {

                List<String> textList = getTextList(file, encoding);
                System.out.println("textList.size " + textList.size());
                for (String text : textList) {
                    words.clear();
                    termsPairs.clear();
                    String[] terms;

                    // ���ķִʴ���(�ִʺ������ܻ�������ͣ�ôʣ�
                    terms = StringEscapeUtil.getTermsbyFilter(text, flag);

                    Integer hvalue;
                    if (terms.length != 0) {
                        hvalue = tmpHead.get(terms[0]);
                        if (hvalue == null) {
                            tmpHead.put(terms[0], new Integer(1));
                        } else {
                            tmpHead.put(terms[0], hvalue + 1);
                        }
                    }

                    for (int ii = 0; ii < terms.length; ii++) {

                        Integer value1 = tmpT.get(terms[ii]);
                        if (value1 == null) {
                            tmpT.put(terms[ii], new Integer(1));
                        } else {
                            tmpT.put(terms[ii], value1 + 1);
                        }

                        if (ii < terms.length - 1) {
                            TermsPair tp = new TermsPair();
                            tp.terms1 = terms[ii];
                            tp.terms2 = terms[ii + 1];

                            //                    		if("玩".equals(tp.terms1)&&"快手".equals(tp.terms2)){
                            //                    			System.out.println(tp);
                            //                    		}
                            termsPairs.add(tp);
                            Integer value2 = tmpTXX.get(tp);
                            if (value2 == null) {
                                tmpTXX.put(tp, new Integer(1));
                            } else {
                                tmpTXX.put(tp, value2 + 1);
                            }

                            //                    		if("玩".equals(tp.terms1)&&"快手".equals(tp.terms2)){
                            //                    			System.out.println(tp + " :: " + tmpTXX.get(tp));
                            //                    		}

                        }
                    }

                    //                    for (String term : terms) { // ���㱾�����ÿ�����ʵĳ��ִ���
                    //                    	Integer value = tmpT.get(term);
                    //                        if(value == null) {
                    //                        	tmpT.put(term, new Integer(1));
                    //                        } else {
                    //                        	tmpT.put(term, value + 1);
                    //                        }
                    //                    }

                    // ��ʼ���� filesOfXC[i]
                    for (String term : terms) { //ȥ���ظ�����
                        words.add(term);
                    }
                    for (String key : words) {
                        Integer value = tmpF.get(key);
                        if (value == null) {
                            tmpF.put(key, new Integer(1));
                        } else {
                            value++;
                            tmpF.put(key, value);
                        }
                    }

                    for (TermsPair tp : termsPairs) {
                        Integer value = tmpFXX.get(tp);
                        if (value == null) {
                            tmpFXX.put(tp, new Integer(1));
                        } else {
                            tmpFXX.put(tp, value + 1);
                        }
                    }
                }
            }

            // ����������е��ʵĳ������� nC
            for (Entry<String, Integer> entry : tmpT.entrySet()) {
                tokensOfC[i] += entry.getValue();
            }

            tokens += tokensOfC[i]; // ���е��ʳ�������
            System.out.println("tokens :: " + classifications[i] + tokens);
            for (Entry<TermsPair, Integer> entry : tmpTXX.entrySet()) {
                ngtokens += entry.getValue();
            }
            System.out.println("ngtokens :: " + classifications[i] + ngtokens);

            long endTime = System.currentTimeMillis();
            System.out.println("class:" + classifications[i] + "类统计时间 :: "
                    + (endTime - startTime) / 1000 / 60 + "mins");
        }

    }

    /**
     * ����ѵ���ı���𷵻��������µ�����ѵ���ı�·��(full path).
     *
     * @param dirStr �ѷ�����ı���Ŀ¼��ĩβ����б��
     * @param classification
     *            �����ķ���
     * @return ���������������ļ���·����full path��
     */
    public static String[] getFilesPath(final String dirStr, final String classification) {
        File classDir = new File(dirStr + File.separator + classification);
        String[] ret = classDir.list();
        for (int i = 0; i < ret.length; i++) {
            ret[i] = dirStr + File.separator + classification + File.separator + ret[i];
        }
        return ret;
    }

    /**
     * ���ظ���·�����ı��ļ�����.
     *
     * @param filePath
     *            �������ı��ļ�·��
     * @param encoding �ı��ļ��ı���
     * @return �ı�����
     * @throws IOException
     *             �ļ��Ҳ�����IO����
     */
    public static String getText(final String filePath, final String encoding) throws IOException {

        InputStreamReader isReader = new InputStreamReader(new FileInputStream(filePath), encoding);
        BufferedReader reader = new BufferedReader(isReader);
        String aLine;
        StringBuilder sb = new StringBuilder();

        while ((aLine = reader.readLine()) != null) {
            sb.append(aLine + " ");
        }
        isReader.close();
        reader.close();
        return sb.toString();
    }

    /**
     * ���ظ���·�����ı��ļ�����.
     *
     * @param filePath
     *            �������ı��ļ�·��
     * @param encoding �ı��ļ��ı���
     * @return �ı�����
     * @throws IOException
     *             �ļ��Ҳ�����IO����
     */
    public static List<String> getTextList(final String filePath, final String encoding)
            throws IOException {

        InputStreamReader isReader = new InputStreamReader(new FileInputStream(filePath), encoding);
        BufferedReader reader = new BufferedReader(isReader);
        String aLine;
        List<String> sbList = new ArrayList<>();
        StringBuilder sb = new StringBuilder();

        while ((aLine = reader.readLine()) != null) {
            sb.append(aLine + " ");
            sbList.add(aLine);
        }
        isReader.close();
        reader.close();
        return sbList;
    }

    /** ��ӡ�����в����Ľ�����Ϣ. */
    private static void usage() {
        System.err.println("usage:\t  <���Ͽ�Ŀ¼> <���Ͽ��ı�����> <�м��ļ�>");
    }

    /**
     * ʹ�÷�����IntermediateData d:\SogouC.mini\Sample\ gbk d:\mini.db
     * @param args
     * @throws IOException
     */
    public static void main(String args[]) throws IOException {
        /*if(args.length < 3) {
        	usage();
        	return;
        }
        IntermediateData tdm = new IntermediateData();
        tdm.generate(args[0], args[1], args[2]);
        */
        File file = new File("E:/work/usertextPorn/newdataclean/result_online");
        BufferedWriter writer;
        writer = new BufferedWriter(new FileWriter(file));
        TGIntermediateData tdm = new TGIntermediateData();
        try {
            tdm.generate("E:/work/usertextPorn/newdataclean/usertext_porn2014121902bg", "utf-8",
                    "E:/NaiveBayesClassifier/src/com/yanjiuyanjiu/text/classification/data/db");
            for (String str : tdm.vocabulary) {
                writer.write(str + " :: " + tdm.tokensOfXC[0].get(str));
                writer.newLine();
            }

        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        writer.close();

        System.out.println("�м��������ɣ�");
    }
}
// CHECKSTYLE:ON
